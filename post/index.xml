<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>博文 on 不争笔记</title>
    <link>/post/</link>
    <description>Recent content in 博文 on 不争笔记</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Fri, 10 May 2019 00:00:00 +0800</lastBuildDate>
    
	<atom:link href="/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>查看 CentOS 版本</title>
      <link>/post/20181217-centos-version/</link>
      <pubDate>Mon, 17 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>/post/20181217-centos-version/</guid>
      <description>&lt;h3 id=&#34;查看-centos-发行版版本&#34;&gt;查看 centos 发行版版本&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# cat /etc/centos-release
CentOS Linux release 7.5.1804 (Core) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# cat /etc/redhat-release 
CentOS Linux release 7.5.1804 (Core) 
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>CentOS 7 中删除预装的 OpenJDK</title>
      <link>/post/20181217-centos7-remove-openjdk/</link>
      <pubDate>Sun, 17 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>/post/20181217-centos7-remove-openjdk/</guid>
      <description>&lt;p&gt;CentOS 7 下安装部署 Java 应用，需要安装 Oracle JRE 做为 JVM。 但是安装完 CentOS 7 之后，经常发现系统已经预先安装了 OpenJDK， 这时候我们需要删除 OpenJDK，可以 通过以下步骤来删除。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>阿里云CentOS挂载新数据盘</title>
      <link>/post/20171206-%E9%98%BF%E9%87%8C%E4%BA%91centos%E6%8C%82%E8%BD%BD%E6%96%B0%E6%95%B0%E6%8D%AE%E7%9B%98/</link>
      <pubDate>Wed, 06 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>/post/20171206-%E9%98%BF%E9%87%8C%E4%BA%91centos%E6%8C%82%E8%BD%BD%E6%96%B0%E6%95%B0%E6%8D%AE%E7%9B%98/</guid>
      <description>&lt;p&gt;在阿里云 Linux 服务器下挂载新的数据盘和自己本机 Linux 环境挂载新硬盘基本是一样的，基本上步骤包括：查看硬盘标识，分区，格式化，挂载等。本文记录下在阿里云 CentOS 服务器下安装和挂载新的数据盘的详细命令和步骤。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Bash Shell 的常用快捷键</title>
      <link>/post/20170805-bash-shell-shortcut-keys/</link>
      <pubDate>Sat, 05 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>/post/20170805-bash-shell-shortcut-keys/</guid>
      <description>&lt;p&gt;对于 Bash 的快捷键一直了解很少，除了常用的 &lt;code&gt;CTRL + a&lt;/code&gt;, &lt;code&gt;CTRL + e&lt;/code&gt; 和 &lt;code&gt;CTRL + l&lt;/code&gt;，其他的基本上都未使用过，这里记录一下（Mac 下请使用 ESC 代替 ALT）。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>X- 开头的 Http Headers</title>
      <link>/post/20170726-http-headers-start-with-x/</link>
      <pubDate>Wed, 26 Jul 2017 00:00:00 +0000</pubDate>
      
      <guid>/post/20170726-http-headers-start-with-x/</guid>
      <description>一些常用的 Http Headers 我们都比较熟悉，比如 Context-Type, Cache-Control, Access 等，这些请求头都有明确的定义，且都是由标准委员会制定的，我们可以称他们为标准的请求头。
在某些时候，我们分析 Http 请求的时候，会发现很多 X- 开头的请求头，这其实是为了区分标准的请求头，这些 X- 开头的请求头多数是由某些企业或者系统自定义的请求头，来达到通过这些请求头来传递某些信息的目的。
比如我们经常见到一下经常使用的 请求头：
 X-Request-With: 这是浏览器添加的用来区分 Ajax 请求的请求头 X-Forwarded-For: 这是由转发设备添加的请求头，用来记录转发设备的 IP X-Auth-Token: 一般用来传递需要认证的 Token 信息  </description>
    </item>
    
    <item>
      <title>Mysql 5.7 从节点配置多线程主从复制</title>
      <link>/post/20170222-mysql-57-slave-multi-thread-replication/</link>
      <pubDate>Wed, 22 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>/post/20170222-mysql-57-slave-multi-thread-replication/</guid>
      <description>&lt;p&gt;Mysql 采用多线程进行复制是从 Mysql 5.6 开始支持的内容，但是 5.6 版本下有缺陷，虽然支持多线程，但是每个数据库只能一个线程，也就是说如果我们只有一个数据库，则主从复制时也只有一个线程在工作。相当于还是以前的单线程。 从 Mysql 5.7 开始支持同一数据库下并行主从复制。不过默认情况下，还是单数据库单个线程，如果需要使用多线程，需要在从节点进行配置。&lt;/p&gt;

&lt;p&gt;Mysql 5.7 对主从复制增加了一种类型，共有两种类型，如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;DATABASE&lt;/code&gt; 基于库的并行复制 ， 每个数据库对应一个复制线程&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LOGICAL_CLOCK&lt;/code&gt;  基于组提交的并行复制方式，同一个数据库下可以有多个线程&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;下面的步骤，在从节点上进行配置。&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>一个简单的 Mysql 备份 BAT 脚本</title>
      <link>/post/20170216-simple-mysql-backup-bat-script/</link>
      <pubDate>Thu, 16 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>/post/20170216-simple-mysql-backup-bat-script/</guid>
      <description>&lt;p&gt;这是一个简单的 Windows 下备份 Mysql 的 BAT 脚本，脚本使用 mysqldump 命令来备份一个指定的 Mysql 数据库到一个文件，文件格式为 &lt;code&gt;%dbname%-yyyyMMddHHmmss.sql&lt;/code&gt;，只保留最近60天的备份。如果想定时执行，在 Windows 中添加&lt;strong&gt;任务计划&lt;/strong&gt;即可。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>CentOS 7 编译安装 Nginx 1.11.10</title>
      <link>/post/20170215-how-to-install-nginx-on-centos-7/</link>
      <pubDate>Wed, 15 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>/post/20170215-how-to-install-nginx-on-centos-7/</guid>
      <description>&lt;p&gt;以前写过一篇 &lt;a href=&#34;//buzheng.org/nginx/centos-nginx-configure-make-install.html&#34;&gt;CentOS 编译安装 nginx 并配置缩略图插件&lt;/a&gt;，当时的环境是 CentOS 6.x 和 Nginx 1.9.x 。 本次安装的环境为 CentOS 7.2 和  Nginx 1.11.10, 有些配置以前自启动的方式发生了变化， 这里再记录一下。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Flex 布局学习笔记</title>
      <link>/post/20170119-flex-layout-note/</link>
      <pubDate>Thu, 19 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>/post/20170119-flex-layout-note/</guid>
      <description>&lt;p&gt;Flex 布局，也称为弹性布局，是为了适应不同的屏幕尺寸和不同的设备类型二提出的一种布局方式。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Ubuntu 安装 mongodb 3.4</title>
      <link>/post/20170118-install-mongodb-on-ubuntu/</link>
      <pubDate>Wed, 18 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>/post/20170118-install-mongodb-on-ubuntu/</guid>
      <description>&lt;p&gt;今天参照 mongodb 的&lt;a href=&#34;https://docs.mongodb.com/manual/tutorial/install-mongodb-on-ubuntu/&#34;&gt;官方文档&lt;/a&gt;在 Unbuntu Server 16.04 上安装了 Mongodb 3.4，步骤很简单，就顺手翻译了一下这个文档，这个文档是讲述了 Mongodb 3.4 在 Ubuntu 12.04, 14.04, 16.04 上的安装步骤。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Mongodb 开启访问控制</title>
      <link>/post/20170114-mongodb-enable-access-control/</link>
      <pubDate>Sat, 14 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>/post/20170114-mongodb-enable-access-control/</guid>
      <description>&lt;p&gt;Mongodb 数据库默认情况下是没有访问控制的，整个数据库对外是开发的，只要能连上数据库，则可以进行任何操作，这会对数据带来很大的风险。当然，我们可以启用mongodb的访问控制，只让通过认证的用户才能对数据库进行角色范围内的操作。&lt;/p&gt;

&lt;p&gt;启用访问控制可以通过在启动 mongodb 时指定 &lt;code&gt;--auth&lt;/code&gt; 参数来设置，另外还涉及到创建用户 db.createUser 操作以及一些角色的定义，我们先来看这部分内容。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Mac OS X 下 eclipse 安装 svn 插件</title>
      <link>/post/20161128-mac-os-x-%E4%B8%8B-eclipse-%E5%AE%89%E8%A3%85-svn-%E6%8F%92%E4%BB%B6/</link>
      <pubDate>Mon, 28 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>/post/20161128-mac-os-x-%E4%B8%8B-eclipse-%E5%AE%89%E8%A3%85-svn-%E6%8F%92%E4%BB%B6/</guid>
      <description>&lt;p&gt;最近开发环境转到 mac 下，mac 属于 unix 系，使用起来跟 windows 差别较大，就连常用的 eclipse 下安装 svn 插件都遇到一些问题，主要报错为 JavaHL 找不到，本文记录一下解决方案。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>聊斋之罗刹海市</title>
      <link>/post/20160806-%E8%81%8A%E6%96%8B%E4%B9%8B%E7%BD%97%E5%88%B9%E6%B5%B7%E5%B8%82/</link>
      <pubDate>Mon, 08 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>/post/20160806-%E8%81%8A%E6%96%8B%E4%B9%8B%E7%BD%97%E5%88%B9%E6%B5%B7%E5%B8%82/</guid>
      <description>&lt;p&gt;《罗刹海市》是《聊斋志异》里面的一个故事，大致故事如下：&lt;/p&gt;

&lt;p&gt;马骥是一个当时长相相当漂亮的商人，从小喜好读书、歌舞，后来继承父亲的生意，做生意也做的相当不错。&lt;/p&gt;

&lt;p&gt;等生意做到一定规模之后，对父亲说想去国外看看能不能过点国外的生意，父亲允许后就渡船出发了，没想到海上遇到海浪落入海中，后来抱着一块木头飘到岸边，到了罗刹国。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>ZooKeeper 集群安装笔记</title>
      <link>/post/20160716-zookeeper-install-notes/</link>
      <pubDate>Sat, 16 Jul 2016 00:00:00 +0000</pubDate>
      
      <guid>/post/20160716-zookeeper-install-notes/</guid>
      <description>&lt;p&gt;本文回顾一下以前学习 zookeeper 的笔记，简单记录下 zookeeper 安装和配置步骤，以及简单的操作命令。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Virtualbox UEFI 配置问题</title>
      <link>/post/20160323-virtualbox-uefi-boot-error/</link>
      <pubDate>Wed, 23 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>/post/20160323-virtualbox-uefi-boot-error/</guid>
      <description>&lt;p&gt;最近在 Virtualbox 中安装 Ubuntu Server 时，由于在主板中选择了“启用EFI(只针对某些操作系统)”导致 Ubuntu 引导不起来，这里记录一下解决方案。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>专职测试是必须的吗</title>
      <link>/post/20160312-%E4%B8%93%E8%81%8C%E6%B5%8B%E8%AF%95%E6%98%AF%E5%BF%85%E9%A1%BB%E7%9A%84%E5%90%97/</link>
      <pubDate>Sat, 12 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>/post/20160312-%E4%B8%93%E8%81%8C%E6%B5%8B%E8%AF%95%E6%98%AF%E5%BF%85%E9%A1%BB%E7%9A%84%E5%90%97/</guid>
      <description>&lt;p&gt;测试是软件生命周期中很重要的一步，对软件的质量提供保障。测试角色在软件过程中是必不可少的，但是专职的测试人员呢？如果专职的测试人员不必须，那么测试角色将有谁来扮演呢？&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>由 DevOps 展开</title>
      <link>/post/20160311-%E7%94%B1-devops-%E5%B1%95%E5%BC%80/</link>
      <pubDate>Fri, 11 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>/post/20160311-%E7%94%B1-devops-%E5%B1%95%E5%BC%80/</guid>
      <description>&lt;p&gt;虽然 DevOps 很热，但是自己一直没有弄清楚。他是谁？他从哪里来？他到哪里去？&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Java Stream 学习笔记</title>
      <link>/post/20160226-java-stream-api-notes/</link>
      <pubDate>Fri, 26 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>/post/20160226-java-stream-api-notes/</guid>
      <description>&lt;p&gt;什么是 Stream ? 这里的 Stream 不同于 io 中的 InputStream 和 OutputStream，Stream 位于包 java.util.stream 中， 也是 java 8 新加入的，Stream 只的是一组支持串行并行聚合操作的元素，可以理解为集合或者迭代器的增强版。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Java Lambda 表达式学习笔记</title>
      <link>/post/20160224-lambda-expression-notes/</link>
      <pubDate>Wed, 24 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>/post/20160224-lambda-expression-notes/</guid>
      <description>&lt;p&gt;Java Lambda 表达式是 Java 8 引入的一个新的功能，可以说是模拟函数式编程的一个语法糖，类似于 Javascript 中的闭包，但又有些不同，主要目的是提供一个函数化的语法来简化我们的编码。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Amazon 内部软件设计原则</title>
      <link>/post/20160130-amazon-inner-software-rules/</link>
      <pubDate>Sat, 30 Jan 2016 00:00:00 +0000</pubDate>
      
      <guid>/post/20160130-amazon-inner-software-rules/</guid>
      <description>&lt;p&gt;网上摘录的一段文字，对 Amazon 内部软件的设计规定非常有感触，非常认同。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>CentOS 7 安装 redis 3.0.6 集群</title>
      <link>/post/centos7-install-redis-cluster/</link>
      <pubDate>Sat, 30 Jan 2016 00:00:00 +0000</pubDate>
      
      <guid>/post/centos7-install-redis-cluster/</guid>
      <description>&lt;p&gt;本文记录 CentOS 7 下 安装 redis 3.0.6 并配置集群的过程。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Mysql 配置主从复制</title>
      <link>/post/centos7-mysql57-replication/</link>
      <pubDate>Mon, 18 Jan 2016 00:00:00 +0000</pubDate>
      
      <guid>/post/centos7-mysql57-replication/</guid>
      <description>&lt;p&gt;Mysql 5.7.10 配置主从复制的步骤很简单，这里记录下配置全新的主从复制的步骤。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>CentOS 7 安装 mysql 5.7.10</title>
      <link>/post/centos7-install-mysql57/</link>
      <pubDate>Fri, 15 Jan 2016 00:00:00 +0000</pubDate>
      
      <guid>/post/centos7-install-mysql57/</guid>
      <description>&lt;p&gt;本文记录 CentOS 7 下安装 mysql 5.7.10 及简单的配置步骤。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>CentOS 7 下安装并启用 iptables</title>
      <link>/post/centos7-install-and-enable-iptables/</link>
      <pubDate>Wed, 13 Jan 2016 00:00:00 +0000</pubDate>
      
      <guid>/post/centos7-install-and-enable-iptables/</guid>
      <description>&lt;p&gt;CentOS 7 安装成功后，发现 iptables 并不能使用，这是因为 CentOS 7 中启用了新的防火墙 firewalld，如果想使用 iptables 则需要安装。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>CentOS 7 下不能使用 ifconfig 命令</title>
      <link>/post/centos7-ifconfig-not-found/</link>
      <pubDate>Tue, 12 Jan 2016 00:00:00 +0000</pubDate>
      
      <guid>/post/centos7-ifconfig-not-found/</guid>
      <description>CentOS 7 为最小化安装，安装完成后，ifconfig 命令不能使用，究其原因是因为没有安装 net-tools 工具包，安装后就可以了。
yum install net-tools  </description>
    </item>
    
    <item>
      <title>正则匹配连续数字</title>
      <link>/post/regex-match-consequent-numbers/</link>
      <pubDate>Fri, 13 Nov 2015 00:00:00 +0000</pubDate>
      
      <guid>/post/regex-match-consequent-numbers/</guid>
      <description>&lt;p&gt;今天有个网友问了匹配连续数字的正则，刚好无事，就帮忙写了一下，算是当作温习一下吧。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Tomcat 监测脚本</title>
      <link>/post/tomcat-inspector-script/</link>
      <pubDate>Thu, 29 Oct 2015 00:00:00 +0000</pubDate>
      
      <guid>/post/tomcat-inspector-script/</guid>
      <description>&lt;p&gt;通过 Tomcat 监测脚本 按照一定的时间频度来检测Tomcat应用是否正常，如果进程不存在，则启动 Tomcat；如果进程存在而访问不正常，则杀掉进程，再启动 Tomcat。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Oracle 进程、连接相关</title>
      <link>/post/oracle-process-session-notes/</link>
      <pubDate>Fri, 23 Oct 2015 00:00:00 +0000</pubDate>
      
      <guid>/post/oracle-process-session-notes/</guid>
      <description>&lt;p&gt;默认情况下，Oracle 允许的最大进程数为 150，这往往不能满足实际环境的要求，因此我们需要修改进程数和会话数的配置。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>垃圾优先垃圾回收器(G1 GC)使用笔记</title>
      <link>/post/g1-gc-notes/</link>
      <pubDate>Tue, 20 Oct 2015 00:00:00 +0000</pubDate>
      
      <guid>/post/g1-gc-notes/</guid>
      <description>&lt;p&gt;G1 GC 是一种新的垃圾回收策略，从 JDK7 开始，主要适用于服务器端的JVM，和大内存的应用，其目标是达到类似 CMS 的高吞吐量。G1 中依然有分代管理的思想，主要采用分块管理的思想，通过将内存分为不超过2048个块，每块大小在 1M-32M 之间， Eden、Survivor space 和 年老代 都是一系列不连续的逻辑区域。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>通过直接拷贝数据文件实现 Oracle 迁移</title>
      <link>/post/oracle-migration-by-copy-data-file/</link>
      <pubDate>Thu, 17 Sep 2015 00:00:00 +0000</pubDate>
      
      <guid>/post/oracle-migration-by-copy-data-file/</guid>
      <description>&lt;p&gt;Oracle 数据迁移是比较麻烦的，作为菜鸟来说更是如此。最近由于更换服务器，需要将 Oracle 迁移到另外一台机器，在两个服务器环境相同，以及 Oracle 版本相同的前提下，通过直接拷贝数据文件到新服务器，就可以直接迁移成功。这里记录一下迁移步骤。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>scp 命令</title>
      <link>/post/linux-scp-notes/</link>
      <pubDate>Sat, 12 Sep 2015 00:00:00 +0000</pubDate>
      
      <guid>/post/linux-scp-notes/</guid>
      <description>&lt;p&gt;&lt;code&gt;scp&lt;/code&gt; 命令用于在不同 linux 机器之间拷贝/复制文件、目录，是 &lt;code&gt;cp&lt;/code&gt; 命令的加强版。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Oracle 用户相关操作</title>
      <link>/post/oracle-user-notes/</link>
      <pubDate>Mon, 07 Sep 2015 00:00:00 +0000</pubDate>
      
      <guid>/post/oracle-user-notes/</guid>
      <description>&lt;p&gt;这里记录一下 Oracle 中用户相关的操作。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>cron 学习笔记</title>
      <link>/post/linux-cron-notes/</link>
      <pubDate>Mon, 07 Sep 2015 00:00:00 +0000</pubDate>
      
      <guid>/post/linux-cron-notes/</guid>
      <description>&lt;p&gt;cron 是 linux/unix 下的一个计划任务管理工具，相当于 Windows 下的计划任务，可以帮助我们按计划、定时的执行某些指定的任务，本文是在使用过程中做的简单的笔记。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>oracle 查看执行最慢 sql</title>
      <link>/post/oracle-slow-sql/</link>
      <pubDate>Fri, 21 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>/post/oracle-slow-sql/</guid>
      <description>&lt;p&gt;&lt;strong&gt;查询执行最慢的sql&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select *
  from (select sa.SQL_TEXT,
               sa.SQL_FULLTEXT,
               sa.EXECUTIONS &amp;quot;执行次数&amp;quot;,
               round(sa.ELAPSED_TIME / 1000000, 2) &amp;quot;总执行时间&amp;quot;,
               round(sa.ELAPSED_TIME / 1000000 / sa.EXECUTIONS, 2) &amp;quot;平均执行时间&amp;quot;,
               sa.COMMAND_TYPE,
               sa.PARSING_USER_ID &amp;quot;用户ID&amp;quot;,
               u.username &amp;quot;用户名&amp;quot;,
               sa.HASH_VALUE
          from v$sqlarea sa
          left join all_users u
            on sa.PARSING_USER_ID = u.user_id
         where sa.EXECUTIONS &amp;gt; 0
         order by (sa.ELAPSED_TIME / sa.EXECUTIONS) desc)
 where rownum &amp;lt;= 50;
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>ORA-01654 索引无法通过128扩展, 表空间不足错误</title>
      <link>/post/ora-01654-unable-to-extend-index/</link>
      <pubDate>Tue, 18 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>/post/ora-01654-unable-to-extend-index/</guid>
      <description>&lt;p&gt;今早系统突然报错：ORA-01654,索引无法通过128(在表空间USERS中) 扩展，究其原因是由于表空间不足引起的。查了表空间以及数据文件的使用情况，发现表空间数据文件 /u01/app/oracle/oradata/orcl/users01.dbf 已经达到最大32G了，所以只能对表空间再添加一个数据文件解决（一个表空间可以对应多个数据文件）。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>centos 6.5 修改 SSH 端口并禁用 root 远程登录</title>
      <link>/post/centos-modify-ssh-port-and-forbid-root-remote/</link>
      <pubDate>Wed, 12 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>/post/centos-modify-ssh-port-and-forbid-root-remote/</guid>
      <description>&lt;p&gt;我们知道 SSH 的默认端口为 22，但是基于安全的需要，我们需要修改服务器的 SSH 端口，和禁用 root 远程登录。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Tomcat 安装配置 Native APR 模式</title>
      <link>/post/tomcat-native-apr-install/</link>
      <pubDate>Tue, 04 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>/post/tomcat-native-apr-install/</guid>
      <description>&lt;p&gt;APR 能大幅提高 tomcat 的性能是不争的事实，但我并没有做过性能比较测试。本文记录 CentOS 6.5 下为 tomcat 7 安装和配置 APR 模式的步骤和过程。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>slf4j &#43; log4j 2 配置</title>
      <link>/post/slf4j-log4j2-configure/</link>
      <pubDate>Tue, 30 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>/post/slf4j-log4j2-configure/</guid>
      <description>本文不提 log4j2 相比较 log4j 和 logback 有多么出色的性能提升，这里只记录 slf4j + log4j 2 的简单配置。
 maven 项目
 增加 maven 依赖 &amp;lt;properties&amp;gt; &amp;lt;slf4j.version&amp;gt;1.7.7&amp;lt;/slf4j.version&amp;gt; &amp;lt;log4j.version&amp;gt;2.1&amp;lt;/log4j.version&amp;gt; &amp;lt;/properties&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.slf4j&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;slf4j-api&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${slf4j.version}&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.logging.log4j&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;log4j-slf4j-impl&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${log4j.version}&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.logging.log4j&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;log4j-api&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${log4j.version}&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.logging.log4j&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;log4j-core&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${log4j.version}&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt;  配置 log4j2.xml log4j 2 相比较 log4j 配置文件完全变了，需要重新配置。下面是一个demo配置，供参考。
&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt; &amp;lt;Configuration&amp;gt; &amp;lt;appenders&amp;gt; &amp;lt;Console name=&amp;quot;Console&amp;quot; target=&amp;quot;SYSTEM_OUT&amp;quot;&amp;gt; &amp;lt;PatternLayout pattern=&amp;quot;%d %-5p %c{1} - %m%n&amp;quot; /&amp;gt; &amp;lt;/Console&amp;gt; &amp;lt;RollingFile name=&amp;quot;DebugRollingFile&amp;quot; fileName=&amp;quot;/www/logs/xxx/debug.</description>
    </item>
    
    <item>
      <title>Oracle 自动备份脚本</title>
      <link>/post/oracle-auto-backup-shell-script/</link>
      <pubDate>Thu, 18 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>/post/oracle-auto-backup-shell-script/</guid>
      <description>&lt;p&gt;本脚本的主要思路是通过 oracle 字典的 exp 命令将数据库导出为 dmp 文件，然后将 dmp 文件打包压缩成 tar.gz 文件，最后将文件 ftp 到远程服务器上。&lt;/p&gt;

&lt;h2 id=&#34;建立脚本文件&#34;&gt;建立脚本文件&lt;/h2&gt;</description>
    </item>
    
    <item>
      <title>oracle 学习笔记</title>
      <link>/post/oracle-notes/</link>
      <pubDate>Mon, 06 Apr 2015 00:00:00 +0000</pubDate>
      
      <guid>/post/oracle-notes/</guid>
      <description>常用命令  lsnrctl status 查看监听状态 lsnrctl start 启动监听 lsnrcrl stop 停止监听 sqlplus &amp;ldquo;/as sysdba&amp;rdquo; 以管理员身份进入命令行  startup 启动数据库实例 shutdown immediate 立刻关闭数据库    oracle启动步骤  启动侦听 lsnrctl start 启动数据库实例  [oracle@linux001 ~]$ sqlplus &amp;quot;/as sysdba&amp;quot; SQL*Plus: Release 11.2.0.1.0 Production on Tue Dec 16 13:50:41 2014 Copyright (c) 1982, 2009, Oracle. All rights reserved. Connected to: Oracle Database 11g Release 11.2.0.1.0 - 64bit Production SQL&amp;gt; startup ORA-01081: cannot start already-running ORACLE - shut it down first SQL&amp;gt; shutdown immediate Database closed.</description>
    </item>
    
    <item>
      <title>Linux 下 ORACLE 启动侦听报错 TNS:permission denied</title>
      <link>/post/oracle-start-listener-permission-denied/</link>
      <pubDate>Thu, 02 Apr 2015 09:00:00 +0000</pubDate>
      
      <guid>/post/oracle-start-listener-permission-denied/</guid>
      <description>今天开发环境 oracle 启动侦听的时候，出现了 TNS:permission denied 的问题，并最终找到了解决方案，现在共享出来。
错误描述 [oracle@oracle ~]$ lsnrctl start LSNRCTL for Linux: Version 11.2.0.1.0 - Production on 27-MAR-2015 15:37:59 Copyright (c) 1991, 2009, Oracle. All rights reserved. Starting /u01/app/oracle/product/11.2.0/dbhome_1/bin/tnslsnr: please wait... TNSLSNR for Linux: Version 11.2.0.1.0 - Production System parameter file is /u01/app/oracle/product/11.2.0/dbhome_1/network/admin/listener.ora Log messages written to /u01/app/oracle/diag/tnslsnr/oracle/listener/alert/log.xml Error listening on: (DESCRIPTION=(ADDRESS=(PROTOCOL=IPC)(KEY=EXTPROC1521))) TNS-12555: TNS:permission denied TNS-12560: TNS:protocol adapter error TNS-00525: Insufficient privilege for operation Linux Error: 1: Operation not permitted Listener failed to start.</description>
    </item>
    
    <item>
      <title>Vi 常用命令汇总</title>
      <link>/post/vi-usages/</link>
      <pubDate>Tue, 31 Mar 2015 23:09:09 +0000</pubDate>
      
      <guid>/post/vi-usages/</guid>
      <description>VI 是 unix/linux 系统下最常用的一个文本编辑工具，其命令也很多，本文是我以前从网上收藏的一边文章的，具体出处不记得了，贴在这里供自己查阅使用，同时向原作者表示感谢。
使用VI打开文件  vi filename：打开或新建文件，并将光标置于第一行首 vi +n filename：打开文件，并将光标置于第n行首 vi + filename：打开文件，并将光标置于最后一行首 vi +/pattern filename：打开文件，并将光标置于第一个与pattern匹配的串处 vi -r filename：在上次正用vi编辑时发生系统崩溃，恢复filename vi filename&amp;hellip;.filename：打开多个文件，依次进行编辑  移动光标类命令  h：光标左移一个字符 l：光标右移一个字符 space：光标右移一个字符 Backspace：光标左移一个字符 k或Ctrl+p：光标上移一行 j或Ctrl+n：光标下移一行 Enter：光标下移一行 w或W：光标右移一个字至字首 b或B：光标左移一个字至字首 e或E：光标右移一个字至字尾 )：光标移至句尾 (：光标移至句首 }：光标移至段落开头 {：光标移至段落结尾 nG：光标移至第n行首 n+：光标下移n行 n-：光标上移n行 n$：光标移至第n行尾 H：光标移至屏幕顶行 M：光标移至屏幕中间行 L：光标移至屏幕最后行 0：（注意是数字零）光标移至当前行首 $：光标移至当前行尾  屏幕翻滚类命令  Ctrl+u：向文件首翻半屏 Ctrl+d：向文件尾翻半屏 Ctrl+f：向文件尾翻一屏 Ctrl＋b：向文件首翻一屏 nz：将第n行滚至屏幕顶部，不指定n时将当前行滚至屏幕顶部。  插入文本类命令  i：在光标前 I：在当前行首 a：光标后 A：在当前行尾 o：在当前行之下新开一行 O：在当前行之上新开一行 r：替换当前字符 R：替换当前字符及其后的字符，直至按ESC键 s：从当前光标位置处开始，以输入的文本替代指定数目的字符 S：删除指定数目的行，并以所输入文本代替之 ncw或nCW：修改指定数目的字 nCC：修改指定数目的行  删除命令  ndw或ndW：删除光标处开始及其后的n-1个字 do：删至行首 d$：删至行尾 ndd：删除当前行及其后n-1行 x或X：删除一个字符，x删除光标后的，而X删除光标前的 Ctrl+u：删除输入方式下所输入的文本  搜索及替换命令  /pattern：从光标开始处向文件尾搜索pattern ?</description>
    </item>
    
    <item>
      <title>iptables 使用笔记</title>
      <link>/post/iptables-notes/</link>
      <pubDate>Tue, 31 Mar 2015 23:08:09 +0000</pubDate>
      
      <guid>/post/iptables-notes/</guid>
      <description>iptables 是 linux 下的防火墙程序，在所有的 linux 发行版中都能使用。
iptables 从名字上看就是基于 tables的，其层次结构为 iptables -&amp;gt; tables -&amp;gt; chains -&amp;gt; rules。 iptables 中包括4个 table ：Filter, NAT, Mangle, Raw；filter 表包含了三种 Chain: INPUT, OUTPUT, FORWARD；在每个 Chain 下，可以定义各种 rule 。
 filter 是默认的表，本文所有操作只涉及 filter 表; 所有操作的用户为 root。
 查看现有规则 举例
iptables -L iptables -L -n iptables -L -n --line-number iptables -L -t filter  参数说明
 -L / &amp;ndash;list 列表显示 -n / &amp;ndash;numeric 用数字显示端口号，默认显示服务名 &amp;ndash;line-number 显示行号 -t / &amp;ndash;table 指定表，可用值: filter(默认), nat, mangle, raw  添加规则 iptables 每个 chain 中包含了若干规则，当需要验证规则的时候，iptables 会逐条判断规则，当前规则条件不满足的时候会进入下一个规则判定。 每一个规则由条件和目标(target)组成，目标就是当满足规则条件时，要对连接进行的操作。 target 有下面的四个值：</description>
    </item>
    
    <item>
      <title>jQuery validation 多个相同name解决方案</title>
      <link>/post/jquery-validate-multiple-same-name-fields/</link>
      <pubDate>Tue, 31 Mar 2015 00:00:00 +0000</pubDate>
      
      <guid>/post/jquery-validate-multiple-same-name-fields/</guid>
      <description>jQuery validation 是非常优秀的前端验证插件，能够帮我们很方便的对前端的 Form 组件进行验证，在使用的过程中也发现了一些问题，比如，当存在多个 name 相同的表单域时，不能正确的进行验证，针对这个问题，在网上搜索了两段代码来使 jQuery validate 支持多个name相同的表单域。
代码片段1 if ($.validator) { //fix: when several input elements shares the same name, but has different id-ies.... $.validator.prototype.elements = function () { var validator = this, rulesCache = {}; // select all valid inputs inside the form (no submit or reset buttons) // workaround $Query([]).add until http://dev.jquery.com/ticket/2114 is solved return $([]).add(this.currentForm.elements) .filter(&amp;quot;:input&amp;quot;) .not(&amp;quot;:submit, :reset, :image, [disabled]&amp;quot;) .not(this.settings.ignore) .filter(function () { var elementIdentification = this.</description>
    </item>
    
    <item>
      <title>centos 6.5 安装 oracle 11gR2 及配置Oracle自动启动</title>
      <link>/post/centos-65-install-oracle-11g-r2/</link>
      <pubDate>Sun, 29 Mar 2015 00:00:00 +0000</pubDate>
      
      <guid>/post/centos-65-install-oracle-11g-r2/</guid>
      <description>CentOS 下安装 Oracle 是一件比较麻烦的事情，这里记录了在 centos 6.5 下安装 oracle 11gR2的前的配置步骤，以及安装完成后，如何设置为随系统自动启动。配置完成后，启动图形化安装，没有什么可说的，本文就没有一一截图，掠过了。 以下命令使用 root 用户操作
 安装依赖包 主要思路为配置 oracle yum 仓库，直接使用 yum 命令来安装依赖包，避免手工逐个的安装依赖包。
配置 yum 仓库以下载 orcale 依赖包 注意这里是CentOS 6.X 的 oracle 依赖仓库，其他版本不同的。
cd /etc/yum.repos.d wget https://public-yum.oracle.com/public-yum-ol6.repo --no-check-certificate  导入 GPG Keys wget https://public-yum.oracle.com/RPM-GPG-KEY-oracle-ol6 -O /etc/pki/rpm-gpg/RPM-GPG-KEY-oracle --no-check-certificate  安装 oracle 依赖 yum install oracle-rdbms-server-11gR2-preinstall  设置 hostname 打开文件 /etc/sysconfig/network，并修改 HOSTNAME。
vi /etc/sysconfig/network NETWORKING=yes HOSTNAME=oracle.buzheng.org  打开 /etc/host， 添加服务器本机IP地址 指向到 HOSTNAME
vi /etc/hosts 192.</description>
    </item>
    
    <item>
      <title>centos 6.5 安装 oracle jdk 8u40</title>
      <link>/post/centos-65-install-oracle-jdk-8/</link>
      <pubDate>Fri, 27 Mar 2015 23:18:09 +0000</pubDate>
      
      <guid>/post/centos-65-install-oracle-jdk-8/</guid>
      <description>采用 oracle jdk 压缩版本进行安装，无废话，直接上干货。安装前准备 惯例，安装之前先升级 yum update  搜索其他版本jdk rpm -qa | grep -E &#39;^open[jre|jdk]|j[re|dk]&#39;  输出
pygobject2-doc-2.20.0-5.el6.x86_64 libbasicobjects-0.1.1-11.el6.x86_64 cjet-0.8.9-9.1.el6.x86_64 cjkuni-uming-fonts-0.2.20080216.1-36.el6.noarch cjkuni-fonts-common-0.2.20080216.1-36.el6.noarch pygobject2-devel-2.20.0-5.el6.x86_64 java-1.7.0-openjdk-devel-1.7.0.75-2.5.4.0.el6_6.x86_64 java-1.6.0-openjdk-devel-1.6.0.34-1.13.6.1.el6_6.x86_64 cjkuni-ukai-fonts-0.2.20080216.1-36.el6.noarch java-1.6.0-openjdk-1.6.0.34-1.13.6.1.el6_6.x86_64 pygobject2-codegen-2.20.0-5.el6.x86_64 eject-2.1.5-17.el6.x86_64 openjpeg-libs-1.3-10.el6_5.x86_64 pygobject2-2.20.0-5.el6.x86_64 java-1.7.0-openjdk-1.7.0.75-2.5.4.0.el6_6.x86_64 openjade-1.3.2-36.el6.x86_64  删除其他版本jdk yum remove java-1.6.0-openjdk yum remove java-1.7.0-openjdk  下载安装 oracle jdk 我选择安装在 /opt 下，所以进入到 /opt 目录下 下载文件
cd /opt  开始下载文件，使用下面的命令能直接下载 oracle jdk 8u40
# 64位 wget --no-cookies --no-check-certificate --header &amp;quot;Cookie: gpw_e24=http%3A%2F%2Fwww.oracle.com%2F; oraclelicense=accept-securebackup-cookie&amp;quot; &amp;quot;http://download.oracle.com/otn-pub/java/jdk/8u40-b25/jdk-8u40-linux-x64.tar.gz&amp;quot; # 32位 wget --no-cookies --no-check-certificate --header &amp;quot;Cookie: gpw_e24=http%3A%2F%2Fwww.</description>
    </item>
    
    <item>
      <title>CentOS 6.5 安装远程桌面工具 xrdp 0.6.1</title>
      <link>/post/centos-65-install-xrdp-061/</link>
      <pubDate>Thu, 26 Mar 2015 00:00:00 +0000</pubDate>
      
      <guid>/post/centos-65-install-xrdp-061/</guid>
      <description>linux 远程桌面工具中，除了 vnc ，xrdp也是很不错的，连接速度很快，直接使用微软的远程桌面工具mstsc即可链接。下面整理一下安装配置步骤。 使用root用户进行以下操作
 安装依赖包 yum upgrade yum install gcc pam-devel openssl-devel libXfont pixman libX11-devel libXfixes-devel autoconf automake libtool yum install tigervnc-server yum groupinstall Desktop  这里包含了 vnc-server ，这是必须的，否则最后都安装成功后，登录后会出错，错误信息大致如下：
connecting to sesman ip 127.0.0.1 port 3350 sesman connect ok sending login info to session manager, please wait... xrdp_mm_process_login_response: login successful for display started connecting connecting to 127.0.0.1 5910 error - problem connecting  安装 xrdp 下载文件、解压缩、编译、安装。
wget http://sourceforge.</description>
    </item>
    
    <item>
      <title>Apache CXF wsdl2java 生成客户端简单用法</title>
      <link>/post/cxf-wsdl2java-simple-usage/</link>
      <pubDate>Wed, 25 Mar 2015 00:00:00 +0000</pubDate>
      
      <guid>/post/cxf-wsdl2java-simple-usage/</guid>
      <description>cxf中带的工具包 wsdl2java 很方便的帮我们生成客户端程序，使用方式如下：
wsdl2java -d d:\src -encoding utf-8 -autoNameResolution -client http://xx.x?wsdl  不指定包明的话，会按照 wsdl中的包结构生成。生成程序后，可直接参考 *_Client.java 中的例子即可执行，无需依赖 cxf 任何jar包。
更多 wsdl2java 的用法可参考： http://cxf.apache.org/docs/wsdl-to-java.html cxf下载地址：http://cxf.apache.org/download.html</description>
    </item>
    
    <item>
      <title>File 对象的 separator 与  pathSeparator</title>
      <link>/post/file-separator-vs-pathseparator/</link>
      <pubDate>Wed, 25 Mar 2015 00:00:00 +0000</pubDate>
      
      <guid>/post/file-separator-vs-pathseparator/</guid>
      <description>File对象中提供了依赖于系统的分隔符，提供了4个静态方法：
 separatorChar char; 文件路径分割符: unix/linux 为 &amp;lsquo;/&amp;rsquo;, windows 为 &amp;lsquo;\&amp;lsquo; pathSeparatorChar char; 路径列表分隔符: unix/linux 为 &amp;lsquo;:&amp;lsquo;, windows 为 &amp;lsquo;;&amp;rsquo; separator String; separatorChar的字符串类型 pathSeparato String; pathSeparatorChar的字符串类型  </description>
    </item>
    
    <item>
      <title>Nginx&#43;tomcat 负载均衡发布应用新版本</title>
      <link>/post/nginx-tomcat-deploy-app-new-version/</link>
      <pubDate>Sun, 20 Jul 2014 00:00:00 +0000</pubDate>
      
      <guid>/post/nginx-tomcat-deploy-app-new-version/</guid>
      <description>&lt;p&gt;本文记录在 &lt;a href=&#34;../ubuntu-keepalived-nginx-tomcat-load-lalance/&#34;&gt;Nginx+tomcat 负载均衡环境&lt;/a&gt; 下，当需要发布新版的tomcat应用时采取的几种方法。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Ubuntu下配置 keepalived&#43;nginx&#43;tomcat 负载均衡</title>
      <link>/post/ubuntu-keepalived-nginx-tomcat-load-lalance/</link>
      <pubDate>Sun, 29 Jun 2014 00:00:00 +0000</pubDate>
      
      <guid>/post/ubuntu-keepalived-nginx-tomcat-load-lalance/</guid>
      <description>&lt;p&gt;本文力图阐述在 Ubuntu Server 环境下使用 Keepalived + Nginx + Tomcat 搭建高可用负载均衡环境的操作步骤和简约配置，这里不涉及性能调优。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Maven多环境配置管理几种方案</title>
      <link>/post/maven-profile-for-multiple-enviroments/</link>
      <pubDate>Wed, 25 Jun 2014 00:00:00 +0000</pubDate>
      
      <guid>/post/maven-profile-for-multiple-enviroments/</guid>
      <description>&lt;p&gt;开发环境、测试环境、生成环境…… 在开发中，我们需要面对各种各样的环境，并且，各个环境的参数和配置各不相同，比如数据库连接，服务器配置等。Maven作为一个项目管理和自动化构建工具，当然也给了我们解决方案，但是项目中的情况较多，这里列举几种常用的多环境的配置管理方案。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>使用github作为maven仓库</title>
      <link>/post/github-maven-repository/</link>
      <pubDate>Tue, 17 Jun 2014 00:00:00 +0000</pubDate>
      
      <guid>/post/github-maven-repository/</guid>
      <description>&lt;p&gt;本文介绍的这种使用 github 作为 maven 仓库的思路主要为：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;github的项目上创建mvn-repo分支，使用mvn-repo分支作为maven仓库&lt;/li&gt;
&lt;li&gt;配 置 pom.xml 使用 target/mvn-repo 作为本地部署的临时maven仓库&lt;/li&gt;
&lt;li&gt;部署时使用 github site-maven-plugin 将本地的maven仓库 push 到 github 的项目的分支 mvn-repo 上去&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    
    <item>
      <title>instanceof, isInstance, isAssignableFroms</title>
      <link>/post/instanceof-isinstance-isassignablefrom/</link>
      <pubDate>Mon, 14 Apr 2014 00:00:00 +0000</pubDate>
      
      <guid>/post/instanceof-isinstance-isassignablefrom/</guid>
      <description>&lt;p&gt;在一些工具代码或者通用操作逻辑中，在运行时了解一个对象的实际类型有时候是很有必要的。对于如何检查当前对象的类型，或者与父类型、其他类型进行比较，Java为我们提供了如下途径：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;操作符 instanceof&lt;/li&gt;
&lt;li&gt;Class.isInstance&lt;/li&gt;
&lt;li&gt;Class.isAssignableFrom&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>软件架构模式的种类</title>
      <link>/post/architectural-patterns/</link>
      <pubDate>Sat, 15 Feb 2014 00:00:00 +0000</pubDate>
      
      <guid>/post/architectural-patterns/</guid>
      <description>&lt;p&gt;在做软件架构设计时,根据不同的抽象层次可分为三种不同层次的模式：架构模式(Architectural Pattern)、设计模式(Design Pattern)、代码模式(Coding Pattern)。&lt;/p&gt;

&lt;p&gt;架构模式是一个系统的高层次策略，涉及到大尺度的组件以及整体性质和力学。架构模式的好坏可以影响到总体布局和框架性结构。&lt;/p&gt;

&lt;p&gt;设计模式是中等尺度的结构策略。这些中等尺度的结构实现了一些大尺度组件的行为和它们之间的关系。模式的好坏不会影响到系统的总体布局和总体框架。设计模式定义出子系统或组件的微观结构。&lt;/p&gt;

&lt;p&gt;代码模式（或成例）是特定的范例和与特定语言有关的编程技巧。代码模式的好坏会影响到一个中等尺度组件的内部、外部的结构或行为的底层细节，但不会影响到一个部件或子系统的中等尺度的结构，更不会影响到系统的总体布局和大尺度框架。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>MyBatis 物理分页插件</title>
      <link>/post/mybatis-pageable-plugin/</link>
      <pubDate>Wed, 18 Dec 2013 00:00:00 +0000</pubDate>
      
      <guid>/post/mybatis-pageable-plugin/</guid>
      <description>我对分页组件有着比较简单原始的想法，就是传入一个分页参数对象，分页组件将分页对象返回。组件实现用到了Mybatis的拦截器，由于对Mybatis的原理并没有深入研究过，有些代码直接拷贝自网上，先按想法实现功能。
主要思路 1、分页对象采用spring-data中的Page和Pageable，其中Pageable作为分页请求，Page为返回的分页对象。 2、拦截器会对方法中的参数进行分析，如果发现Pageable类型的参数，则认为是分页请求，将请求封装为Page对象返回。
拦截器配置 &amp;lt;plugins&amp;gt; &amp;lt;plugin interceptor=&amp;quot;org.buzheng.commons.mybatis.MybatisPageableInterceptor&amp;quot;&amp;gt; &amp;lt;property name=&amp;quot;dialectClass&amp;quot; value=&amp;quot;org.buzheng.commons.mybatis.MySQLDialect&amp;quot;/&amp;gt; &amp;lt;/plugin&amp;gt; &amp;lt;/plugins&amp;gt;  Mapper接口方法写法 public interface SysUserDao { Page&amp;lt;SysUser&amp;gt; findPageByParams(Map&amp;lt;String, Object&amp;gt; params, Pageable pageRequest); }  Mapper.xml 写法(和普通查询一样) &amp;lt;select id=&amp;quot;findPageByParams&amp;quot; resultType=&amp;quot;SysUser&amp;quot;&amp;gt; &amp;lt;include refid=&amp;quot;findSql&amp;quot; /&amp;gt; &amp;lt;where&amp;gt; &amp;lt;if test=&amp;quot;param1.groupId != null&amp;quot;&amp;gt; u.group_id = #{param1.groupId} &amp;lt;/if&amp;gt; &amp;lt;/where&amp;gt; ORDER BY u.add_time &amp;lt;/select&amp;gt;  service 调用写法 @Service public class SysUserServiceImpl implements SysUserService { @Resource private SysUserDao sysUserDao; @Override public Page&amp;lt;SysUser&amp;gt; findPage(Map&amp;lt;String, Object&amp;gt; params, int pageNo, int pageSize) { Pageable pageRequest = new PageRequest(pageNo, pageSize); return this.</description>
    </item>
    
    <item>
      <title>使用keytools 为 tomcat 7 配置ssl 双向认证</title>
      <link>/post/keytools-tomcat-7-ssl/</link>
      <pubDate>Fri, 19 Jul 2013 00:00:00 +0000</pubDate>
      
      <guid>/post/keytools-tomcat-7-ssl/</guid>
      <description>&lt;h2 id=&#34;第一-证书库-证书等生成&#34;&gt;第一、证书库、证书等生成&lt;/h2&gt;

&lt;h3 id=&#34;1-生成服务器证书库&#34;&gt;1、生成服务器证书库&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;keytool -validity 36500 -genkey -v -alias tomcat_server -keyalg RSA -keystore tomcat_server.keystore -dname &amp;quot;CN=127.0.0.1,OU=,O=,L=,ST=,c=&amp;quot; -storepass 123456 -keypass 123456
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;-validity 36500 有效期，以天为单位
CN 这项一定是服务器的域名或者IP地址
OU 组织单位
O 组织
L 区域
ST 州/省份
C 国家&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>IE XDomainRequest 学习笔记</title>
      <link>/post/ie-xdomainrequest-note/</link>
      <pubDate>Sat, 13 Jul 2013 00:00:00 +0000</pubDate>
      
      <guid>/post/ie-xdomainrequest-note/</guid>
      <description>&lt;p&gt;W3C CORS（跨域资源共享）是对于跨域请求的一个规范，目前各个主流浏览器都实现了这个规范，IE8开始，增加了XDomainRequest作为跨域请求的对象，而Firefox与Chrom则CORS直接实现在XMLHttpRequest对象中，更方便使用。不过IE10中，XMLHttpRequest对象也实现了CORS。本文主要总结 XDomainRequest 对象一些使用方法。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>原生 JSON 工具类对象</title>
      <link>/post/the-native-json-util-object/</link>
      <pubDate>Wed, 03 Jul 2013 00:00:00 +0000</pubDate>
      
      <guid>/post/the-native-json-util-object/</guid>
      <description>&lt;p&gt;今天才知道原生的JSON对象，惭愧惭愧， 这里对他的用法做一下记录。&lt;/p&gt;

&lt;p&gt;我们都知道json是采用javascript对象的格式来存储数据的数据格式，这就不免和javascript对象之间经常转化，以前经常需要地方的库，现在不用了，原生的javascript自带了JSON对象，可以很方便的完成转化。JSON对象提供了2个方法：parse 和 stringify。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;JSON.parse：将json数据转为javascript对象&lt;/li&gt;
&lt;li&gt;JSON.stringify：将javascript对象序列化成json数据&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>设计模式学习 - Abstract Factory Pattern</title>
      <link>/post/abstract-factory-pattern/</link>
      <pubDate>Tue, 21 May 2013 00:00:00 +0000</pubDate>
      
      <guid>/post/abstract-factory-pattern/</guid>
      <description>&lt;p&gt;前几天总结了&lt;a href=&#34;../factory-method-pattern/&#34;&gt;工厂方法模式&lt;/a&gt;：将创建对象的部分抽象，留作具体的子类来创建。当时也说过，工厂方法是抽象工厂的一个特例。那么抽象工厂解决什么问题呢？抽象工厂主要用于存在一组产品或者产品族的场景中。所谓产品族，就是一组有关联的产品。对产品和工厂都进行抽象，客户端只知道抽象的工厂和产品，而不需要关心具体的工厂和产品，具体选择哪个工厂，由上下文来来决定。贴一下抽象工厂通用类图。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>设计模式学习 – State Pattern</title>
      <link>/post/state-pattern/</link>
      <pubDate>Fri, 17 May 2013 00:00:00 +0000</pubDate>
      
      <guid>/post/state-pattern/</guid>
      <description>&lt;p&gt;模式解决问题的思路都是相同的，找到变化的部分封装起来，用来解决某一类特定的问题。状态模式同样是用来出来多路分支的情况，不过在岔口要根据对象的状态来进行选择，对象的不同状态决定了选择不同的分支。既然状态是变化的，我们就考虑将状态封装，由上下文保存当前的状态，由状态对象决定下一步的操作。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>设计模式学习 - Factory Method Pattern</title>
      <link>/post/factory-method-pattern/</link>
      <pubDate>Tue, 14 May 2013 00:00:00 +0000</pubDate>
      
      <guid>/post/factory-method-pattern/</guid>
      <description>&lt;p&gt;封装变化是我们在设计的时候要遵循的一个基本原则，这也是设计模式的基础。工厂方法这个模式中变化的部分是：创建对象的部分。由于这部分逻辑不确定，抽象类只是定义了一个创建操作接口，具体的实现需要延迟到子类来，由每个具体子类负责创建一个具体的产品，这跟抽象工厂模式是很接近的，可以说工厂方法是&lt;a href=&#34;/abstract-factory-pattern.html&#34;&gt;抽象工厂&lt;/a&gt;的一个特例。下面是一个通用的Factory Method 类图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/factory-method.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>bash shell 编程学习注记</title>
      <link>/post/bash-shell-script-note/</link>
      <pubDate>Tue, 07 May 2013 00:00:00 +0000</pubDate>
      
      <guid>/post/bash-shell-script-note/</guid>
      <description>&lt;p&gt;常用shell有很多：bourne shell(/usr/bin/sh或者/bin/sh), Bourne Again Shell(/bin/bash), C Shell(/usr/bin/csh), K Shell(/usr/bin/ksh), Shell for Root(/sbin/sh)。每种shell都有自己的用法和语法。今天我主要学习的是 bash，因为bash比较广泛，是很多linux的默认shell。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>设计模式学习 - Proxy Pattern</title>
      <link>/post/proxy-pattern/</link>
      <pubDate>Fri, 03 May 2013 00:00:00 +0000</pubDate>
      
      <guid>/post/proxy-pattern/</guid>
      <description>Proxy Pattern，代理模式。代理是我们经常用到的一个概念，比如我们常用的代理服务器，还有一些公司业务的代理人等，都是代理。我们平时只与代理打交道，把我们的要求告诉代理，然后又代理帮助我们去处理，处理完成后，再将结果反馈给我们。
我们先看一下 Proxy Pattern 的类图。
proxy pattern class diagram
代理服务器：是用来代理上网的，我们设置好代理服务器之后，所有的请求都发往代理服务器，代理服务器会帮助我们完成下载网页，传输数据等操作。同时代理服务器也可以统计流量，过滤一些内容等。
从代理服务器我们可以看出，代理不但能帮助我们完成功能，还可以在流程中添加一些控制（统计流量、过滤内容），这对我们很有启发。比如在我们平时的业务处理层中，某些业务处理类专职于处理某中业务逻辑，而此时如果我们需要添加一些权限控制，安全性控制，或者日志服务等，如果直接修改业务类原有代码，肯定不是最佳的实践。不但违反了开闭原则，也违反了类的单一职责原则，导致过多的职责都添加到业务类中，使业务类除了业务逻辑外还负责了许多本不该他负责的职责。 下面的就是一个简单的日志代理的例子。
IHello接口定义个了一个操作sayHello。
package org.buzheng.study.pattern.proxy; public interface IHello { public void sayHello(String name); } HelloSpeaker是IHello的一个具体实现。 ``` java package org.buzheng.study.pattern.proxy; public class HelloSpeaker implements IHello { public void sayHello(String name) { System.out.println(&amp;quot;hello &amp;quot; + name); } }  HelloStaticProxy是一个代理类，负责添加日志的功能，在操作的前后都记录日志。
package org.buzheng.study.pattern.proxy; public class HelloLoggingProxy implements IHello { private IHello hello; public HelloLoggingProxy(IHello hello) { super(); this.hello = hello; } public void sayHello(String name) { System.</description>
    </item>
    
    <item>
      <title>快速排序</title>
      <link>/post/quick-sort/</link>
      <pubDate>Sun, 28 Apr 2013 00:00:00 +0000</pubDate>
      
      <guid>/post/quick-sort/</guid>
      <description>&lt;p&gt;快速排序也是一种交换排序。首先选定一个基准元素（一般取第一个或最后一个元素），根据基准元素，将序列分为2个子序列，左边子序列的全部元素都小于等于基准元素，右边序列的全部元素都大于等于该基准元素。然后对左右这两个序列，递归重复上面的算法，直到序列排序完成。&lt;/p&gt;

&lt;p&gt;快速排序的时间复杂度期望是 O(n&lt;strong&gt;&lt;em&gt;log&lt;/em&gt;&lt;/strong&gt;(n))，最慢可达到 O(n&lt;sup&gt;2&lt;/sup&gt;)。一般在一个乱序的大列表中，快速排序还是最快的排序算法。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>冒泡排序</title>
      <link>/post/bubble-sort/</link>
      <pubDate>Tue, 23 Apr 2013 00:00:00 +0000</pubDate>
      
      <guid>/post/bubble-sort/</guid>
      <description>&lt;p&gt;冒泡排序是一个常见的交换排序方法。冒泡的算法大意：在未排序的队列中从头遍历，开始比较相邻的2个元素，如果这个元素不符合要求的顺序，则交换位置，经过一遍比较之后，最小的元素就会到达序列的首位；然后将剩下的序列作为未排序的序列，重复上面的算法，直到整个序列排序完成。由于在排序的过程中，一直向前移动，看起来有点像水里的气泡向水面漂浮一样，故得此名。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>TCP的三次握手和四次握手</title>
      <link>/post/tcp-3-way-handshake-and-4-way-handshake/</link>
      <pubDate>Thu, 11 Apr 2013 00:00:00 +0000</pubDate>
      
      <guid>/post/tcp-3-way-handshake-and-4-way-handshake/</guid>
      <description>&lt;p&gt;TCP是面向连接的传输协议，在TCP通信过程中客户端和服务器之间会保留一个虚拟连接，为了建立这个虚拟连接，需要3次握手进行确认。连接结束的时候又需要4次握手进行确认。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>最长公共子字符串与最长公共子序列</title>
      <link>/post/longest-common-substring-subsequence/</link>
      <pubDate>Wed, 20 Mar 2013 00:00:00 +0000</pubDate>
      
      <guid>/post/longest-common-substring-subsequence/</guid>
      <description>最长公共子字符串（longest common substring）与最长公共子序列（longest common subsequence）是不一样的，substring 要求字符连续，subsequence只要求字符顺序一样，不要求连续。关于这两个题目的解法，都说是采用动态规划算法，研究了半天，暂时还没研究透彻（人老迟钝了么？）。这里暂且记住这两个题目的解法。这个题目的解法思路大致相同，都是构造一个二维数组（XY的位置分别对应两个字符串的索引的位置），根据字母的对应关系，在矩阵的相应位置上构造数字。构造完成后，再从最大的数字回朔，然后找到相应的串。
最长公共子字符串 先看最长公共子字符串的解法，根据2个字符串的长度构造一个二维数组a[][]，按照下面条件对数组个位置构造数值。
若s1[i]!=s2[j]，则a[i][j]=0 若s1[i]==s2[j]，则a[i][j]=a[i-1][j-1]+1 就拿abcdefg和xcdef来举例，构造出的数组如下：
 a b c d e f g x 0 0 0 0 0 0 0 c 0 0 1 0 0 0 0 d 0 0 0 2 0 0 0 e 0 0 0 0 3 0 0 f 0 0 0 0 0 4 0  下面是java实现代码：
public class LongestCommonSubstring { public String search(String s1, String s2) { if (s1 == null || s1.</description>
    </item>
    
    <item>
      <title>设计模式学习 - Template Method Pattern</title>
      <link>/post/template-method-pattern/</link>
      <pubDate>Wed, 13 Mar 2013 00:00:00 +0000</pubDate>
      
      <guid>/post/template-method-pattern/</guid>
      <description>&lt;p&gt;Template Method （模板方法），从他的名字我们就可以看得出，这个模式抽象为一个模板。模板方法为我们解决某个算法提供了一个抽象的实现骨架，确定的步骤可以直接实现，不确定（有变化）的部分，则推迟到具体的子类来实现。算法的使用者只需依赖于模板，具体使用哪个模板，则由上下文指定。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Git对于SVN的优势</title>
      <link>/post/advantage-of-git-to-svn/</link>
      <pubDate>Tue, 12 Mar 2013 00:00:00 +0000</pubDate>
      
      <guid>/post/advantage-of-git-to-svn/</guid>
      <description>Git是一个相当出色的版本控制工具，相对于SVN，Git有很多优势。
1、Git是分布式的 Git是分布式的，没有客户端/服务端的概念，每个仓库既是客户端，可以是服务端，每一份都是对git仓库的一个完整拷贝。而SVN是C/S模式的，有一个中央服务器。分布式的好处是显而易见的，只要世界上还有一台机器上有一个Git拷贝，你的代码就不会丢失。而SVN若是服务器坏掉了，我只有哭的份。
2、Git很少需要联网 由于Git是分布式的，每一份都是对Git仓库的一个完整拷贝，所以大多数情况下，你只需要在本地完成开发，包括：创建分支、合并分支、删除分支等等。只有极少的操作才会用到联网：fetch, push, pull等。而SVN则不同，他可能需要你经常连线服务器。
3、Git占用的空间相当少 Git占用的空间相当少，并且不会每个目录里都产生配置文件，他的配置文件只会在根目录有。SVN的痛苦都体验过吧，部署的时候，是不是每次都要删除所有的 .svn目录，并且配置文件当地多，占用了很多你的地盘？？
4、Git分支相当容易操作 由于git是在本地，你很容易创建分支和合并分支。当你有修改的需求的时候，一般会创建一个分支，在分支上进行修改，然后将分支合并到master分支上；即使后来需求有变，不需要修改了，而你只需要删除分支即可。
5、Git相当容易学习 Git的常用的命令20多个，学习起来相当容易。就拿初始化Git仓库来说，只需要git init一行命令。点击此处查看git常用命令。
本文只是一家之言，Git和SVN都是不错的工具，都尝试一下，可以体会一下不同门派的思想。</description>
    </item>
    
    <item>
      <title>利用javascript事件的特性高效的为子元素绑定操作</title>
      <link>/post/javascript-binding-event/</link>
      <pubDate>Mon, 11 Mar 2013 00:00:00 +0000</pubDate>
      
      <guid>/post/javascript-binding-event/</guid>
      <description>有这样一道javascript题目：在如下dom结构中，如何高效的给li元素绑定click事件，在用户单击li元素时能够提示li中的内容？
&amp;lt;ul&amp;gt; &amp;lt;li&amp;gt;xxx&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;xxx&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;xxx&amp;lt;/li&amp;gt; &amp;lt;!-- 后续还有大量li元素 --&amp;gt; &amp;lt;/ul&amp;gt;  最初想法就是遍历每个li元素，循环给li绑定onclick事件，如同下面的代码一样：
window.onload = function() { var ul = document.getElementById(&#39;ul&#39;); var lis = ul.getElementsByTagName(&#39;li&#39;); for (var i = lis.length-1; i &amp;gt;= 0; i--) { lis[i].onclick = function(e) { alert(this.innerHTML); } } };  这种想法当然是最简单最直观也是正确的，但是存在一点问题，当dom中的li元素特别多的时候，这样循环遍历的绑定操作势必会站用大量的资源，这时候我们可以使用事件的一些特性，将操作绑定到li的父元素ul上面，当事件触发的时候，从event对象的属性中获取当前操作的对象，然后再完成其他的操作。如下面代码：
window.onload = function() { var ul = document.getElementById(&#39;ul&#39;); ul.onclick = function(e) { e = window.event ? window.event : e; var who = e.target ? e.target : e.srcElement; alert(who.</description>
    </item>
    
    <item>
      <title>linux 上安装 virtualmin/webmin</title>
      <link>/post/install-virtualmin-webmin-on-linux/</link>
      <pubDate>Wed, 06 Mar 2013 00:00:00 +0000</pubDate>
      
      <guid>/post/install-virtualmin-webmin-on-linux/</guid>
      <description>&lt;p&gt;Webmin是一个可视化的linux管理工具，囊括了所有的linux管理功能；而Virtualmin则是基于webmin的网站虚拟主机管理面板，可以很方便的帮助我们建站（FTP，Apache、mysql、php等）。这里说一下如何在linux系统上安装virtualmin和webmin。&lt;/p&gt;

&lt;p&gt;Virtualmin给我提供了一个安装脚本，可以一键安装webmin和virtualmin。virtualmin分为免费版和专业版，对于我来说，免费版就够了。这个页面（&lt;a href=&#34;http://virtualmin.com/download.html&#34;&gt;http://virtualmin.com/download.html&lt;/a&gt;）是virtualmin官方的下载安装说明。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>设计模式学习 - Strategy Pattern</title>
      <link>/post/strategy-pattern/</link>
      <pubDate>Wed, 27 Feb 2013 00:00:00 +0000</pubDate>
      
      <guid>/post/strategy-pattern/</guid>
      <description>&lt;p&gt;Strategy Pattern （策略模式）是对一系列可以替换的策略（算法）进行抽象，具体算法继承与抽象，在不同的场景下可以选择不同的算法，这样的好处就是将策略的使用者与具体的策略解耦。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>设计模式学习 - Decorator Pattern</title>
      <link>/post/decorator-pattern/</link>
      <pubDate>Sun, 03 Feb 2013 00:00:00 +0000</pubDate>
      
      <guid>/post/decorator-pattern/</guid>
      <description>&lt;p&gt;Decorator Pattern （装饰者模式）提供了动态增加对象行为的方式，他在原有对象的基础上动态的增加额外的职责。基本结构如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/decorator.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>设计模式学习 - Null Object Pattern</title>
      <link>/post/null-object-pattern/</link>
      <pubDate>Thu, 31 Jan 2013 00:00:00 +0000</pubDate>
      
      <guid>/post/null-object-pattern/</guid>
      <description>&lt;p&gt;Null Object Pattern （空对象模式）是在某些场景下，使用一个 Null Object 来代替返回的 null, 通过这个 NullObject，使用者能够像使用普通对象一样，而不需要 null 判断，让逻辑更顺畅，让代码看起来很干净，很清爽。&lt;/p&gt;

&lt;p&gt;那什么是 Null Object？Null Object 就是一个普通对象的特例，他一般继承于普通对象，然后对一些操作进行了重写，让这些操作符合无意义 或 空操作。对这个对象的一切操作，就像没有进行过操作一样。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>设计模式学习 - Observer Pattern</title>
      <link>/post/observer-pattern/</link>
      <pubDate>Tue, 29 Jan 2013 00:00:00 +0000</pubDate>
      
      <guid>/post/observer-pattern/</guid>
      <description>Observer Pattern （观察者模式、侦听器模式、订阅发布模式、模式-视图模式）适用于有需要通知的场景。当某些对象依赖于某个对象的某个状态，需要在这个对象到达某个状态时进行某些操作时，可将这些对象注册到需要监视的对象（主题）上，当这个对象（主题）到达某个状态时，主动通知这些对象，从而化主动为被动，使具体的观察者对象和要关注的主题解耦。下面一个普遍的结构图：
在 JDK 中，已经内置了 java.util.Observer 接口 和 java.util.Obserable 类。Observer 接口，就是观察者的抽象，定义了 update 操作。Obserable 类，则实现了观察者注册、删除和通知的逻辑，主题对象一般只要继承这个类即可。
观察者模式是一个很常用的模式，tomcat 中就大量使用了观察者。
尽管观察者模式一个比较简单的模式，但是我们在使用的过程中应该注意以下问题： 1，如果观察者对象太多，主题对象的通知操作可能会很慢，这时可能将通知过程做成异步或通过线程池进行管理，就像消息队列那样。 2，如果观察者对象之间的操作互有依赖，则通知时，可能会有操作混乱。</description>
    </item>
    
    <item>
      <title>内连接、左联接、右连接、交叉连接</title>
      <link>/post/inner-outer-left-right-cross-join/</link>
      <pubDate>Thu, 24 Jan 2013 00:00:00 +0000</pubDate>
      
      <guid>/post/inner-outer-left-right-cross-join/</guid>
      <description>&lt;p&gt;当多表存在关联时，一般使用连接进行关联查询。连接一般分为：内连接、外连接， 这里做一个总结。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;内连接(inner join)&lt;/strong&gt;，返回的是2个表中满足条件的记录的组合。
&lt;strong&gt;左外连接(left join/left outer join)&lt;/strong&gt;，以左表的记录为基础，右表符合条件便组合，不符合条件则以空字段留空。
&lt;strong&gt;右外连接(right join/right outer join)&lt;/strong&gt;，以右表的记录为基础，左表符合条件便组合，不符合条件则以空字段留空。
&lt;strong&gt;全外连接(full join/full outer join)&lt;/strong&gt;，相当于左外连接和右外连接的 union。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>SQL &amp; DB 一些 总结</title>
      <link>/post/summary-of-sql-and-db/</link>
      <pubDate>Mon, 21 Jan 2013 00:00:00 +0000</pubDate>
      
      <guid>/post/summary-of-sql-and-db/</guid>
      <description>&lt;h2 id=&#34;不要使用-select&#34;&gt;不要使用 select *&lt;/h2&gt;

&lt;p&gt;这个很好理解，select * 至少会增加查询表字段这个过程。使用了 select *，可能会多查询出不用的字段，浪费系统资源；可能会导致无用的字段在网络中传输从而浪费带宽；在程序处理结果的时候，可能会处理无用的字段，浪费系统资源。&lt;/p&gt;

&lt;p&gt;另外，根据原则：明言胜于暗示。将字段写明，无论对于系统资源的节约，还是对于后来阅读程序的朋友，都有好处。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>在 Eclipse 中用 tomcat 调试 maven web 工程</title>
      <link>/post/eclipse-tomcat-maven-web/</link>
      <pubDate>Sun, 20 Jan 2013 00:00:00 +0000</pubDate>
      
      <guid>/post/eclipse-tomcat-maven-web/</guid>
      <description>&lt;p&gt;在 Eclipse 中用 Jetty 调试 maven web 工程是很方便的，但是大家一般习惯tomcat，这里说一下如何在配置到tomcat中运行。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>JAVA 一些基础知识点滴</title>
      <link>/post/java-notes-one-by-one/</link>
      <pubDate>Sat, 19 Jan 2013 00:00:00 +0000</pubDate>
      
      <guid>/post/java-notes-one-by-one/</guid>
      <description>&lt;p&gt;本文主要是记录一些java的基础知识，发现什么记什么，没有什么次序性。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>设计模式学习 - Adapter Pattern</title>
      <link>/post/adapter-pattern/</link>
      <pubDate>Fri, 18 Jan 2013 00:00:00 +0000</pubDate>
      
      <guid>/post/adapter-pattern/</guid>
      <description>&lt;p&gt;Adapter Pattern 用以解决当前类和目标接口不匹配的情况，他通过增加一个适配类来是当前类和目标接口达成一致。结构如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/object-adapter.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>设计模式学习 - Iterator Pattern</title>
      <link>/post/iterator-pattern/</link>
      <pubDate>Thu, 17 Jan 2013 00:00:00 +0000</pubDate>
      
      <guid>/post/iterator-pattern/</guid>
      <description>&lt;p&gt;Iterator Pattern 属于行为模式，她为如何访问集合的内部定义了统一的访问方式。有了这个统一的访问方式，那些集合类的使用者对所有的集合都可以使用统一的方式来访问，而不关心是什么集合。下面是一个通用的结构图&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/iterator.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>我所知道的正则表达式（3）- 零宽断言</title>
      <link>/post/regex-zero-width-assertion/</link>
      <pubDate>Wed, 16 Jan 2013 00:00:00 +0000</pubDate>
      
      <guid>/post/regex-zero-width-assertion/</guid>
      <description>&lt;p&gt;正则表达式里面比较高级的应用就属于零宽断言了。那么什么是零宽断言呢？拆分法从字面上分析一下，零宽，即宽度为0，意味者不会返回匹配的字符，以为匹配的是当前字符的位置。断言，就是预言、假设，意味着从此处假设存在什么情况。那么零宽断言的意思就是假定从此位置开始满足某种情况。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>我所知道的正则表达式（2）- 贪婪模式与懒惰模式</title>
      <link>/post/regex-greedy-mode/</link>
      <pubDate>Tue, 15 Jan 2013 00:00:00 +0000</pubDate>
      
      <guid>/post/regex-greedy-mode/</guid>
      <description>了解了正则表达式基础知识已经能够能应付大多数情况，像字符串匹配、正则替换、校验等；但是再使用的过程中你可能发现一个问题，就是当使用重复元字符匹配数量时，总是会尽可能长的去匹配，而有时这恰恰不是你想要的。看下面的例子：
&amp;lt;a href=”http://www.google.com”&amp;gt;谷歌&amp;lt;/a&amp;gt;&amp;lt;a href=”http://www.baidu.com”&amp;gt;百度&amp;lt;/a&amp;gt;  你希望匹配出每个链接的html内容。如果你用 &amp;lt;a (.*)&amp;lt;/a&amp;gt;会首先匹配到整个字符串，而不是你希望的&amp;lt;a href=”http://www.google.com”&amp;gt;谷歌&amp;lt;/a&amp;gt;和&amp;lt;a href=”http://www.baidu.com”&amp;gt;百度&amp;lt;/a&amp;gt;。
为什么会出现这种情况呢？这就是正则表达式的贪婪模式。当出现重复数量的时候，会尽可能的多匹配。上述的正则表达式中 . 表示任意字符，* 代表可以重复出现任意个，根据正则表达式的贪婪个性，不匹配到最后才怪呢。就像人一样，有贪婪就有懒惰，一个?就可以让正则立刻改变本性，这时的正则就表现懒惰模式的本性了。
修改后的正则表达式为：&amp;lt;a (.*?)&amp;lt;/a&amp;gt;，这时就可以匹配出每个链接的html了。
测试用例为：
import java.util.regex.Matcher; import java.util.regex.Pattern; public class Test { public static void main(String[] args) throws Exception { String value = &amp;quot;&amp;lt;a href=&amp;quot;http://www.google.com&amp;quot;&amp;gt;谷歌&amp;lt;/a&amp;gt;&amp;lt;a href=&amp;quot;http://www.baidu.com&amp;quot;&amp;gt;百度&amp;lt;/a&amp;gt;&amp;quot;; System.out.println(&amp;quot;贪婪模式：&amp;quot;); Pattern pattern = Pattern.compile(&amp;quot;&amp;lt;a (.*)&amp;lt;/a&amp;gt;&amp;quot;); Matcher matcher = pattern.matcher(value); while (matcher.find()) { System.out.println(matcher.group(0)); } System.out.println(&amp;quot;贪婪模式：&amp;quot;); pattern = Pattern.compile(&amp;quot;&amp;lt;a (.*?)&amp;lt;/a&amp;gt;&amp;quot;); matcher = pattern.matcher(value); while (matcher.find()) { System.out.println(matcher.group(0)); } } }  最后总结一下数量元字符懒惰模式的常用写法(其实就是多了一个?</description>
    </item>
    
    <item>
      <title>折腾 Ubuntu</title>
      <link>/post/ubuntu-notes/</link>
      <pubDate>Mon, 14 Jan 2013 00:00:00 +0000</pubDate>
      
      <guid>/post/ubuntu-notes/</guid>
      <description>&lt;p&gt;最近开始学习使用ubuntu，于是在virtual box上安装了ubuntu server来折腾，安装的时候，什么都没有默认安装，所以什么都需要自己手动来安装，顺便学习一下ubuntu。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>innerHTML在ie,firefox,chrome的区别</title>
      <link>/post/innerhtml-ie-firefox-chrome/</link>
      <pubDate>Sun, 13 Jan 2013 00:00:00 +0000</pubDate>
      
      <guid>/post/innerhtml-ie-firefox-chrome/</guid>
      <description>最近在用javascript 写一个代码语法高亮工具，由于取代码部分的时候需要用到innerHTML属性，发现了IE6, IE7, IE8与IE9, firefox, chrome对innerHTML实现的不同。现在IE9已经属于现代浏览器了，实现方式已经和firefox, chrome一致。下面说说区别：
IE6,IE7,IE8会将标签转为大写，对没有关闭的html标签（注意是html标签，比如）进行关闭，并不在意其他的自定义标签(比如)是否关闭，并且会将属性值的引号也给丢掉了。
IE9,firefox,chrome会将标签专为小写，并关闭所有没有关闭的标签。
例如下面一段html代码，要求取div#test的innerHTML值：
&amp;lt;div id=&amp;quot;test&amp;quot;&amp;gt; &amp;lt;span&amp;gt;you are here&amp;lt;/span&amp;gt; &amp;lt;XXXX&amp;gt;xxxx &amp;lt;p&amp;gt;aaa &amp;lt;/div&amp;gt;  在IE9,firefox,chrome下取出的内容为：
&amp;lt;span&amp;gt;you are here&amp;lt;/span&amp;gt; &amp;lt;xxxx&amp;gt;xxxx &amp;lt;p&amp;gt;aaa &amp;lt;/p&amp;gt;&amp;lt;/xxxx&amp;gt;  IE6,IE7,IE8下取出的内容为：
&amp;lt;SPAN class=a&amp;gt;you are here&amp;lt;/SPAN&amp;gt; &amp;lt;XXXX&amp;gt;xxxx &amp;lt;P&amp;gt;aaa &amp;lt;/P&amp;gt;  有时候仅仅是想取出里面的原始内容进行处理的话，还真是个麻烦事。</description>
    </item>
    
    <item>
      <title>渐进增强实现首页弹出层登录</title>
      <link>/post/progressive-enhancement-logon-page/</link>
      <pubDate>Sat, 12 Jan 2013 00:00:00 +0000</pubDate>
      
      <guid>/post/progressive-enhancement-logon-page/</guid>
      <description>先说一下什么渐进增强。 渐进增强是前端开发的一个理念，对于前端开发，首先强调的是内容，然后在当前内容的基础上对功能进行增强。这并不是首先照顾那些低版本或者功能较差的浏览器（如移动浏览器)，因为在渐进增强的理念中甚至没有浏览器的概念。
与之对应的一个概念是“平稳退化“，这个开发理念主张首先针对高级的、现代的浏览器来开发设计网站，而对老的、落伍的浏览器提供一个仅仅可以工作的版本，却没有那么好的体验。
在我看来，这两种理念的思想本身差不多，出发点不太一样，最终都是要保持网站在不同境况带给用户的完整功能，只是有些体验差点，有些体验好些。
我这里会试着用这种前端开发理念，来实现一个首页弹出层登录的功能，我们可以先来探讨一下为什么要使用弹出层登录？我觉得弹出层会有如下2个好处（可能会有些肤浅）：
对用户来说，不用心打开一个页面，节省下载时间；带给用户更好的体验； 对网站提供者来说，至少可以减少一次页面请求，降低服务器负载； 好了，我们来开始来做这个登录的例子。首先我们先按照最原始的思路实现一个登录页面，功能要求就是当用户点击页顶部的登录链接时会跳转到登录页面。我先来完成基本的代码：
html代码：
&amp;lt;div id=&amp;quot;top&amp;quot;&amp;gt; &amp;lt;div class=&amp;quot;wrapper&amp;quot;&amp;gt; &amp;lt;a href=&amp;quot;login.html&amp;quot; id=&amp;quot;signinlink&amp;quot;&amp;gt;Sign In&amp;lt;/a&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt;  基本的样式：
#top { width: 100%; border-botton: 1px solid #ccc; background: #eee; line-height: 24px; height: 24px; over-flow: hidden; } .wrapper { margin: 0 auto; width: 960px; }  就这么简单，我们就完成了跳转到登录页面的功能。这个版本我相信在任何浏览器下都是能工作的，因为任何浏览器都是支持链接的，即使这个浏览器不支持javascript。下面我们要做的就是添加一些辅助代码用以表示登录弹出层的输入框等内容，html代码我修改为如下（其中id为signinpanel就是要弹出的层）：
&amp;lt;div id=&amp;quot;top&amp;quot;&amp;gt; &amp;lt;div class=&amp;quot;wrapper&amp;quot;&amp;gt; &amp;lt;a href=&amp;quot;login.html&amp;quot; id=&amp;quot;signinlink&amp;quot;&amp;gt;Sign In&amp;lt;/a&amp;gt; &amp;lt;div id=&amp;quot;signinpanel&amp;quot;&amp;gt; &amp;lt;label for=&amp;quot;username&amp;quot;&amp;gt;username&amp;lt;/label&amp;gt; &amp;lt;input id=&amp;quot;username&amp;quot; name=&amp;quot;username&amp;quot; /&amp;gt; &amp;lt;label for=&amp;quot;password&amp;quot;&amp;gt;password&amp;lt;/label&amp;gt; &amp;lt;input id=&amp;quot;password&amp;quot; name=&amp;quot;password&amp;quot; /&amp;gt; &amp;lt;button&amp;gt;Sign In&amp;lt;/button&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt;  然后给登录链接添加事件，这里使用了jquery库：</description>
    </item>
    
    <item>
      <title>Git 使用汇总</title>
      <link>/post/git-usage-notes/</link>
      <pubDate>Fri, 11 Jan 2013 00:00:00 +0000</pubDate>
      
      <guid>/post/git-usage-notes/</guid>
      <description>git 基本操作命令 git init 用于初始化一个git仓库 git config user.name &amp;ldquo;buzheng&amp;rdquo; 配置用户名 git config user.email &amp;ldquo;zany@buzheng.org&amp;rdquo; git remote add origin git@xxxx.com:xxxxx_project/xxxx.git 添加远程服务端源 git fetch 获取代码 git pull 获取代码，并进行了merge操作 git add -A 添加所有修改的文件到 index git commit -a -m &amp;ldquo;message&amp;rdquo; 提交到本地仓库 git push 提交到远程服务器 git log 查看提交记录，好像有参数 -p git status 查看当前工作目录的状态，是否有变更等 git diff 查看工作目录与index的不同 git diff –cached 查看index与commit的不同
git branch 查看所有分支，以及当前所处的分支 git branch name 创建分支name git checkout name 切换到分支name git branch -d name 删除分支，安全删除，如果分支没有被提交或者合并，是不能删除的 git branch -D name 删除分支，强制删除 git merge name 合并分支</description>
    </item>
    
    <item>
      <title>Quartz Cron Expression</title>
      <link>/post/quartz-cron-expression/</link>
      <pubDate>Fri, 11 Jan 2013 00:00:00 +0000</pubDate>
      
      <guid>/post/quartz-cron-expression/</guid>
      <description>&lt;h2 id=&#34;表达式格式及字段说明&#34;&gt;表达式格式及字段说明&lt;/h2&gt;

&lt;p&gt;Quartz 定时表达式一般有6个字段单位（也可7个），使用空格间隔。从前到后按照如下的格式：
秒 分 时 日 月 星期[ 年] （最后一个单位“年”是可选的）。&lt;/p&gt;

&lt;!--
| 字段        |允许值                                             | 可用特殊字符      |
| ----------- |---------------------------------------------------| ----------------- |
| 秒          |0-59                                               | , – * /           |
| 分          |0-59                                               | , – * /           |
| 时          |0-23                                               | , – * /           |
| 日          |1-31                                               | , – * ? / L W C   |
| 月          |1-12                                               | , – * /           |
| 星期        |1-7(1=SUN) 或 SUN，MON，TUE，WED，THU，FRI，SAT    | , – * ? / L C #   |
| 年(可选)    |1970－2099                                         | , – * /           | --&gt;

&lt;table border=&#34;1&#34;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;th&gt;字段&lt;/th&gt;&lt;th&gt;允许值&lt;/th&gt;&lt;th&gt;可用特殊字符&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;秒&lt;/td&gt;&lt;td&gt;0-59&lt;/td&gt;&lt;td&gt;, - * /&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;分&lt;/td&gt;&lt;td&gt;0-59&lt;/td&gt;&lt;td&gt;, - * /&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;时&lt;/td&gt;&lt;td&gt;0-23&lt;/td&gt;&lt;td&gt;, - * /&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;日&lt;/td&gt;&lt;td&gt;1-31&lt;/td&gt;&lt;td&gt;, - * ? / L W C&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;月&lt;/td&gt;&lt;td&gt;1-12&lt;/td&gt;&lt;td&gt;, - * /&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;星期&lt;/td&gt;&lt;td&gt;1-7(1=SUN) 或 SUN，MON，TUE，WED，THU，FRI，SAT&lt;/td&gt;&lt;td&gt;, - * ? / L C #&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;年(可选)&lt;/td&gt;&lt;td&gt;1970－2099&lt;/td&gt;&lt;td&gt;, - * /&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;</description>
    </item>
    
    <item>
      <title>我所知道的正则表达式（1）- 基础知识</title>
      <link>/post/regex-basic/</link>
      <pubDate>Fri, 11 Jan 2013 00:00:00 +0000</pubDate>
      
      <guid>/post/regex-basic/</guid>
      <description>&lt;p&gt;正则表达式是处理文本时的有力工具，能够按照一定的模式或规则去匹配具有一定格式的文本，并可以完成分组、替换等复杂功能。作为一程序员，正则作为必备武器，能给我们处理文带来极大的便利。经常用到的正则的场景如：javascript验证输入格式（密码、电话、email等）、网页爬虫从网页中的解析出需要的内容，替换相同模式的文本内容等。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>设计模式学习 - 工厂模式</title>
      <link>/post/factory-pattern/</link>
      <pubDate>Thu, 10 Jan 2013 00:00:00 +0000</pubDate>
      
      <guid>/post/factory-pattern/</guid>
      <description>&lt;p&gt;在面向对象开发原则中有这么一条：对象要么创建和管理对象，要么使用其他对象，不能兼而有之。这也夫单一职责原则的具体应用。其中创建和管理对象的角色就是工厂，他是工厂模式中的主角，他有如下的职责：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;创建对象&lt;/li&gt;
&lt;li&gt;按照约定的规则管理对象&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;使用工厂能改给我们的好处：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;将使用者和被使用者的创建过程/创建逻辑解耦（将使用者和被使用者解耦，因为大多数情况下，使用者不知道被使用者的具体类型）。&lt;/li&gt;
&lt;li&gt;集中创建/管理对象，提高程序的内聚性。&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>压力测试工具siege的用法</title>
      <link>/post/usage-of-siege/</link>
      <pubDate>Tue, 08 Jan 2013 00:00:00 +0000</pubDate>
      
      <guid>/post/usage-of-siege/</guid>
      <description>&lt;p&gt;Siege是linux下的一个web系统的压力测试工具，支持多链接，支持get和post请求，可以对web系统进行多并发下持续请求的压力测试。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>设计模式学习 - Facade Pattern</title>
      <link>/post/facade-pattern/</link>
      <pubDate>Tue, 08 Jan 2013 00:00:00 +0000</pubDate>
      
      <guid>/post/facade-pattern/</guid>
      <description>&lt;p&gt;Facade Pattern 被译成门面模式。他的目的就是想对外部用户隐藏系统/模块/类的复杂性，提供给用户一个简单易用的使用接口。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Tomcat 配置汇总</title>
      <link>/post/tomcat-config/</link>
      <pubDate>Mon, 07 Jan 2013 00:00:00 +0000</pubDate>
      
      <guid>/post/tomcat-config/</guid>
      <description></description>
    </item>
    
    <item>
      <title>简述HTTP协议</title>
      <link>/post/brief-of-http-protocol/</link>
      <pubDate>Sun, 06 Jan 2013 00:00:00 +0000</pubDate>
      
      <guid>/post/brief-of-http-protocol/</guid>
      <description>&lt;h2 id=&#34;什么是协议&#34;&gt;什么是协议？&lt;/h2&gt;

&lt;p&gt;通俗的理解，协议就是双方为了交流而制定的标准，是一种约定的通信方式。就比如我们常说的“点头Yes摇头No”，这就是一种公共的交流协议。网络协议当然是为了在网络上通信而制定的一些标准，比如采用什么端口号，传递什么样的数据，数据采用什么样的格式进行组织等。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>面向对象开发设计原则</title>
      <link>/post/principle-of-ood-ooa-oop/</link>
      <pubDate>Sun, 06 Jan 2013 00:00:00 +0000</pubDate>
      
      <guid>/post/principle-of-ood-ooa-oop/</guid>
      <description>&lt;p&gt;面向对象开发设计过程中，先辈给我们总结了很多的设计原则，这些原则是设计模式的基础，熟练掌握这些原则，对自己的开发设计很有帮助。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>设计模式学习 - Singleton Pattern</title>
      <link>/post/singleton-pattern/</link>
      <pubDate>Sat, 05 Jan 2013 00:00:00 +0000</pubDate>
      
      <guid>/post/singleton-pattern/</guid>
      <description>&lt;p&gt;Singleton Pattern 是一种创建模式，根据译者的不同，可能会译作：单态模式、单例模式、单件模式等。Singleton Pattern的目的是保证某个对象在运行环境中有且只有一个实例。主要的实现思路就是将构造方法私有化（防止由使用者构建对象），然后由对象本身来确保这唯一的实例，并提供一个公共操作来供使用者来获取这唯一的实例。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>I/O概念 &amp; I/O模型 &amp; Java nio 知识整理</title>
      <link>/post/io-model-and-java-nio/</link>
      <pubDate>Thu, 20 Dec 2012 00:00:00 +0000</pubDate>
      
      <guid>/post/io-model-and-java-nio/</guid>
      <description>&lt;p&gt;最近在看java nio相关的资料，最初的看的一头雾水，很对东西模棱两可，于是网上查了些I/O的资料，本文是自己对I/O的一个理解。&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>