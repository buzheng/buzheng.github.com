<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Web Front on 不争笔记</title>
    <link>/tags/web-front/</link>
    <description>Recent content in Web Front on 不争笔记</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Tue, 31 Mar 2015 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="/tags/web-front/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>jQuery validation 多个相同name解决方案</title>
      <link>/post/jquery-validate-multiple-same-name-fields/</link>
      <pubDate>Tue, 31 Mar 2015 00:00:00 +0000</pubDate>
      
      <guid>/post/jquery-validate-multiple-same-name-fields/</guid>
      <description>jQuery validation 是非常优秀的前端验证插件，能够帮我们很方便的对前端的 Form 组件进行验证，在使用的过程中也发现了一些问题，比如，当存在多个 name 相同的表单域时，不能正确的进行验证，针对这个问题，在网上搜索了两段代码来使 jQuery validate 支持多个name相同的表单域。
代码片段1 if ($.validator) { //fix: when several input elements shares the same name, but has different id-ies....  $.validator.prototype.elements = function () { var validator = this, rulesCache = {}; // select all valid inputs inside the form (no submit or reset buttons)  // workaround $Query([]).add until http://dev.jquery.com/ticket/2114 is solved  return $([]).add(this.currentForm.elements) .filter(&amp;#34;:input&amp;#34;) .not(&amp;#34;:submit, :reset, :image, [disabled]&amp;#34;) .</description>
    </item>
    
    <item>
      <title>IE XDomainRequest 学习笔记</title>
      <link>/post/ie-xdomainrequest-note/</link>
      <pubDate>Sat, 13 Jul 2013 00:00:00 +0000</pubDate>
      
      <guid>/post/ie-xdomainrequest-note/</guid>
      <description>&lt;p&gt;W3C CORS（跨域资源共享）是对于跨域请求的一个规范，目前各个主流浏览器都实现了这个规范，IE8开始，增加了XDomainRequest作为跨域请求的对象，而Firefox与Chrom则CORS直接实现在XMLHttpRequest对象中，更方便使用。不过IE10中，XMLHttpRequest对象也实现了CORS。本文主要总结 XDomainRequest 对象一些使用方法。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>原生 JSON 工具类对象</title>
      <link>/post/the-native-json-util-object/</link>
      <pubDate>Wed, 03 Jul 2013 00:00:00 +0000</pubDate>
      
      <guid>/post/the-native-json-util-object/</guid>
      <description>&lt;p&gt;今天才知道原生的JSON对象，惭愧惭愧， 这里对他的用法做一下记录。&lt;/p&gt;

&lt;p&gt;我们都知道json是采用javascript对象的格式来存储数据的数据格式，这就不免和javascript对象之间经常转化，以前经常需要地方的库，现在不用了，原生的javascript自带了JSON对象，可以很方便的完成转化。JSON对象提供了2个方法：parse 和 stringify。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;JSON.parse：将json数据转为javascript对象&lt;/li&gt;
&lt;li&gt;JSON.stringify：将javascript对象序列化成json数据&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>利用javascript事件的特性高效的为子元素绑定操作</title>
      <link>/post/javascript-binding-event/</link>
      <pubDate>Mon, 11 Mar 2013 00:00:00 +0000</pubDate>
      
      <guid>/post/javascript-binding-event/</guid>
      <description>有这样一道javascript题目：在如下dom结构中，如何高效的给li元素绑定click事件，在用户单击li元素时能够提示li中的内容？
&amp;lt;ul&amp;gt; &amp;lt;li&amp;gt;xxx&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;xxx&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;xxx&amp;lt;/li&amp;gt; &amp;lt;!-- 后续还有大量li元素 --&amp;gt; &amp;lt;/ul&amp;gt; 最初想法就是遍历每个li元素，循环给li绑定onclick事件，如同下面的代码一样：
window.onload = function() { var ul = document.getElementById(&amp;#39;ul&amp;#39;); var lis = ul.getElementsByTagName(&amp;#39;li&amp;#39;); for (var i = lis.length-1; i &amp;gt;= 0; i--) { lis[i].onclick = function(e) { alert(this.innerHTML); } } };  这种想法当然是最简单最直观也是正确的，但是存在一点问题，当dom中的li元素特别多的时候，这样循环遍历的绑定操作势必会站用大量的资源，这时候我们可以使用事件的一些特性，将操作绑定到li的父元素ul上面，当事件触发的时候，从event对象的属性中获取当前操作的对象，然后再完成其他的操作。如下面代码：
window.onload = function() { var ul = document.getElementById(&amp;#39;ul&amp;#39;); ul.onclick = function(e) { e = window.event ? window.event : e; var who = e.target ? e.target : e.srcElement; alert(who.innerHTML); }; };  这里我们用到了Event对象的target属性，该属性能够获取事件发生所在的元素。当然在IE下，该功能被srcElement代替。这种方式无疑是简练和高效的，除了照顾浏览器兼容多带来的几行代码外，这段代码多美妙啊。</description>
    </item>
    
  </channel>
</rss>